module B = Ast_grammar_normalized;

let counter = ref(0);
let gen_intermediate_type = () => {
  incr(counter);
  "Intermediate_type" ++ string_of_int(counter^);
}

let wrap_ident= (ident:string) : string => {
   if (ident == "true" || ident == "false") {
      ident ++ "_bool"
   } else {
      ident
   }
}
let codegen_atom = (atom: B.atom): string => {
   switch(atom) {
   | B.TOKEN => "string" /* tokens are string */
   | B.SYMBOL(name) => wrap_ident(name)
   }
}

let codegen_simple =  (simple: B.simple): string => {
   switch(simple) {
   | B.ATOM(atom) => codegen_atom(atom)
   | B.SEQ(atoms) => {
      /* codegen: (A,B,C,...) */
      let atom_strs = List.map(codegen_atom, atoms);
      "(" ++ String.concat(", ", atom_strs) ++ ")"
      }
   }
}

let codegen_rule_body = (rule_body: B.rule_body): string => {
   switch (rule_body) {
   | B.SIMPLE(simple) => {
      codegen_simple(simple);
      }
   | B.CHOICE(simples) => {
      /* codegen: A(...) | B(...) */
      let rhs = List.map(codegen_simple, simples);
      let im_types = List.map(
         (im_type: string) => {
            if (im_type == "true" || im_type == "false") {
               /* add extra quote for boolean */
               gen_intermediate_type() ++ "(" ++ wrap_ident(im_type) ++ ")"
            } else {
               gen_intermediate_type() ++ "(" ++ im_type ++ ")"
            }
         },
         rhs
      );
      String.concat(" | ", im_types);
   }
   | B.REPEAT(simple) => {
      /* codegen: list(x) */
      let rhs = codegen_simple(simple);
      "list(" ++ rhs ++ ")"
   }
   | B.OPTION(simple) => {
      /* codegen: option(...) */
      let rhs = codegen_simple(simple);
      "option(" ++ rhs ++ ")"
   }
   }
}

let codegen_rules = (xs: list(B.rule)): (list(string)) => {
   List.map(((name, body): B.rule) => {
      wrap_ident(name) ++ " = " ++ codegen_rule_body(body)
   }, xs)
}

let codegen = ((_, rules): B.grammar): (string) => {
  let code_header = "/* Auto-generated by codegen_type */\n";
  let rule_strs = codegen_rules(rules);
  code_header ++ "type " ++ String.concat("\nand ", rule_strs) ++ ";";
}

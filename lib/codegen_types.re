module B = Ast_grammar_normalized;

let counter = ref(0);
let gen_intermediate_constructor = () => {
  incr(counter);
  "Intermediate_type" ++ string_of_int(counter^);
}

let wrap_ident= (ident:string) : string => {
   if (ident == "true" || ident == "false") {
      ident ++ "_bool"
   } else {
      ident
   }
}

let codegen_atom = (atom: B.atom): (string, list((string, B.simple))) => {
   switch(atom) {
   | B.TOKEN => ("token", []) /* tokens are empty */
   | B.STRING(string) => ("string" ++ " /* " ++ string ++ " */", [])
   | B.SYMBOL(name) => (wrap_ident(name), [])
   }
}

let codegen_simple =  (simple: B.simple): (string, list((string, B.simple))) => {
   switch(simple) {
   | B.ATOM(atom) => codegen_atom(atom)
   | B.SEQ(atoms) => {
      /* codegen: (A,B,C,...) */
      let atom_strs = List.map(codegen_atom, atoms);
      (
         "(" ++ String.concat(", ", List.map(fst, atom_strs)) ++ ")",
         List.concat(List.map(snd, atom_strs))
      )
      }
   }
}

let codegen_rule_body = (rule_body: B.rule_body): (string, list((string, B.simple))) => {
   switch (rule_body) {
   | B.SIMPLE(simple) => {
      codegen_simple(simple);
      }
   | B.CHOICE(simples) => {
      /* codegen: A(...) | B(...) */
      let simple_strs = List.map((simple) => {
         let (name, ims) = codegen_simple(simple);
         let new_im_type = gen_intermediate_constructor();
         let new_im_list = [(new_im_type, simple), ...ims];
         (new_im_type ++ "(" ++ wrap_ident(name) ++ ")", new_im_list)
      }, simples);
      let combine_im_types = List.map(fst, simple_strs);
      (
         "\n | " ++ String.concat("\n | ", combine_im_types),
         List.concat(List.map(snd, simple_strs))
      );
   }
   | B.REPEAT(simple) => {
      /* codegen: list(x) */
      let simple_str = codegen_simple(simple);
      let rhs = fst(simple_str);
      ("list(" ++ rhs ++ ")", snd(simple_str));
   }
   | B.OPTION(simple) => {
      /* codegen: option(...) */
      let simple_str = codegen_simple(simple);
      let rhs = fst(simple_str);
      ("option(" ++ rhs ++ ")", snd(simple_str));
   }
   }
}

let codegen_rules = (rules: list(B.rule)): (list((string, list((string, B.simple))))) => {
   let rules_sorted_by_type = List.sort(
      ((a_i, a_body): B.rule, (b_i, b_body): B.rule) => {
         if (a_i == "program") {
            /* make sure program is at last */
            1;
         } else if (b_i == "program") {
            -1;
         } else {
            let a_type = B.show_rule_body(a_body);
            let b_type = B.show_rule_body(b_body);
            /* make sure leaves are at top */
            switch(a_body) {
            | B.SIMPLE(B.ATOM(B.TOKEN)) => -1
            | _ => {
               switch(b_body) {
               | B.SIMPLE(B.ATOM(B.TOKEN)) => 1
               | _ => String.compare(a_type, b_type)
               }
            }
            }
         }
      },
      rules
   );
   List.map(((name, body): B.rule) => {
      let rule_body = codegen_rule_body(body);
      (wrap_ident(name) ++ " = " ++ fst(rule_body), snd(rule_body))
   }, rules_sorted_by_type)
}

let codegen = ((_, rules): B.grammar): (string, list((string, B.simple))) => {
  counter := 0;
  let code_header = "/* Auto-generated by codegen_type */\n" ++
      "[@deriving show { with_path : false} ]\n";

  let rules = codegen_rules(rules);
  let rule_strs = List.map(fst, rules);
  (
   code_header ++ "type token = string\nand " ++ String.concat("\nand ", rule_strs) ++ ";",
   List.concat(List.map(snd, rules))
  );
}

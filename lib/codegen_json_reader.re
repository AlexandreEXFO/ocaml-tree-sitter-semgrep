open Common;
module B = Ast_grammar_normalized;

/* let generate_recursive_parser_atom = ((name: string, body: B.atom)): string => {
   switch(body) {
   | B.SYMBOL(string) | B.STRING(string) => {
      spf("
      | J.Object([(\"type\", J.String(\"%s\")),
                  (\"children\", _)]
      ", string)
   }
   | B.TOKEN => ""
   }
} */

let generate_recursive_parser = ((name:string, body: B.rule_body)): string => {
   switch(body) {
   | B.SIMPLE(_) => {
         /* Leaf node */
         spf("
      | J.Object([(\"type\", J.String(\"%s\")),
                  (\"children\", _)]) => %s",
         name,
         name)
      }
   /* | B.SIMPLE(B.SEQ(ls)) => {
      let array_items = String.concat("", List.map(generate_recursive_parser_atom, ls));
      spf("
      | J.Object([(\"type\", J.String(\"expression_statement\")),
                (\"children\", %s
      )]) => Expression_statement(parse_expression_statement(xs))
      ", array_items)
   } */
   | _ => ""
   }
}

let generate_parser_func = (rules: list((string, B.rule_body))): string => {
   let parser_simple_strings = List.map(generate_recursive_parser, rules);
   let parser_func_body = spf("
let rec parse_body = (json: J.json_type):  => {
   switch(json) {%s
    | _ =>  \"Todo: IMPLEMENT THIS CST NODE TYPE\"
    };
}\n"
   , String.concat("", parser_simple_strings));
   parser_func_body
}

let codegen = (_nast: B.grammar, rules: list((string, B.rule_body)), generated_cst_filename: string): string => {
   let header = spf(
"/* DO NOT MODIFY MANUALLY:
Auto-generated by codegen_json_reader*/
open %s
open Common;
module J = Json_type;
let error = (s, json) => failwith(spf(\"Wrong format: %s, got: %s\",s,Json_io.string_of_json(json)));\n",
   generated_cst_filename, "%s", "%s");
   let main = "
   and parse_children = (xs: J.json_type): list(cst_node) => {
    switch(xs) {
    | J.Array(xs) => List.map(parse_body, xs)
    | _ => error(\"Top parse_children\", xs)
    }
}\n";

   let entrypoint = "/*****************************************************************************/
/* Entrypoint */
/*****************************************************************************/
let parse = (file): program_cst => {
    let json = Json_io.load_json(file);
    switch(json) {
    | J.Object(xs) => {
      let children = List.assoc(\"children\",xs);
      parse_children(children)
    }
    | _ => error(\"Toplevel\", json);
    }
}";

   /*
      TODO: refactor codegen_type to emit extra
      TODO-s
      Structure of generated code:
      - recursive parser for complex types
      - parse_body
      - entrypoint
   */
   header ++ generate_parser_func(rules) ++ main ++ entrypoint;
}
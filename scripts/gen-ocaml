#! /usr/bin/env bash
#
# Generate OCaml parsers
#
# For lang=ruby, the file hierarchy we create looks like this:
#
# ocaml-src
# ├── bin
# │   ├── dune
# │   └── Main.ml
# ├── lib
# │   ├── AST.ml
# │   ├── dune
# │   ├── Parse.ml
# │   ├── parser.c
# │   ├── scanner.cc
# │   └── tree_sitter
# │       └── parser.h
# └── tree-sitter.opam
#
#
set -eu -o pipefail

project_root=$(git rev-parse --show-toplevel)
ocaml_tree_sitter="$project_root"/bin/ocaml-tree-sitter

default_dst_dir="ocaml-src"
default_src_dir="src"
default_lang="lang"

usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Call ocaml-tree-sitter to derive an OCaml parsing library and executable
from a tree-sitter grammar in json format, normally generated by
tree-sitter as 'src/grammar.json'.

Options:
  --dst DST_DIR
      Specify the output directory. Default: $default_dst_dir
  --src SRC_DIR
      Location of the 'src' folder with some of its contents generated
      by tree-sitter. It must contain 'grammar.json', 'parser.c',
      and optionally other C files ('scanner.c' or 'scanner.cc') needed
      to build the C parser. Default: $src_dir
  --help
      Show this help message and exit.
  --lang NAME
      Name of the programming language. It will be part of the name
      of the library and of the OCaml module. Case conversion and conversions
      between dashes and underscores will take place as needed.
      Default: $default_lang
EOF
}

error() {
  cat >&2 <<EOF
Error: $*
EOF
  exit 1
}

test -x "$ocaml_tree_sitter" || error "missing executable $ocaml_tree_sitter"

lang="$default_lang"
src_dir="$default_src_dir"
dst_dir="$default_dst_dir"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --dst)
      dst_dir="$2"
      shift
      ;;
    --help)
      usage
      exit 0
      ;;
    --lang)
      lang="$2"
      shift
      ;;
    --src)
      src_dir="$2"
      shift
      ;;
    *)
      error "Unsupported argument: $1"
  esac
  shift
done

lang_dashes=$(echo "$lang" | tr '[A-Z_]' '[a-z-]')
lang_underscores=$(echo "$lang" | tr '[A-Z-]' '[a-z_]')

# Copy what we need to the ocaml-src folder. We need at least to copy
# the C source and headers.
#
rm -rf "$dst_dir"
mkdir -p "$dst_dir"/lib

# Build the lists of C and C++ files to compile, without their extension.
#
c_files="parser"
cxx_files=""

cp "$src_dir"/parser.c "$dst_dir"/lib

if [[ -e "$dst_dir"/lib/scanner.c ]]; then
  cp "$src_dir"/scanner.c "$dst_dir"/lib
  c_files="scanner $c_files"
fi

if [[ -e "$src_dir"/scanner.cc ]]; then
  cp "$src_dir"/scanner.cc "$dst_dir"/lib
  cxx_files="scanner"
fi

# Copy C header files
#
cp -a "$src_dir"/tree_sitter "$dst_dir"/lib/tree_sitter

# Generate the OCaml code needed to parse the examples/*.out json files.
#
"$ocaml_tree_sitter" "$lang_underscores" "$src_dir"/grammar.json -d "$dst_dir"

cat > "$dst_dir"/lib/dune <<EOF
(library
  (public_name tree-sitter.lang-${lang_dashes})
  (name tree_sitter_lang_${lang_underscores})
  (preprocess (pps ppx_sexp_conv))
  (libraries atdgen-runtime tree-sitter.run)
  (foreign_stubs
    (language c)
    (names ${c_files})
    (flags -fPIC
           -I .
           -I %{env:TREESITTER_INCLUDE_DIR=/usr/local/include})
  )
  (c_library_flags (-L%{env:TREESITTER_LIBRARY_DIR=/usr/local/lib}
                    -ltree-sitter))
  (foreign_stubs
    (language cxx)
    (names ${cxx_files})
    (flags -fPIC
           -I .
           -I %{env:TREESITTER_INCLUDE_DIR=/usr/local/include})
  )
)
EOF

cat > "$dst_dir"/bin/dune <<EOF
(executable
  (public_name parse-${lang_dashes})
  (name Main)
  (libraries tree-sitter.lang-${lang_dashes})
)
EOF

# This is needed for building with dune.
#
touch "$dst_dir"/tree-sitter.opam

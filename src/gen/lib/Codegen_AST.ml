(*
   Code generator for the AST.ml file.
*)

open Printf
open AST_grammar
open Codegen_util
open Indent.Types

let trans = translate_ident

let preamble grammar =
  [
    Line (
      sprintf "\
(* Generated by ocaml-tree-sitter. *)
(*
   %s grammar

   entrypoint: %s
*)

open! Sexplib.Conv
open Ocaml_tree_sitter_run
"
        grammar.name
        grammar.entrypoint
    )
  ]

let rec format_body body : Indent.t =
  match body with
  | Symbol ident -> [Line (trans ident)]
  | Token { name = _; description = Constant cst } ->
      [Line (sprintf "Token.t (* %S *)" cst)]
  | Token { name = _; description = Pattern pat } ->
      let pattern_string =
        sprintf "%S" pat
        |> Codegen_util.safe_comment
      in
      [Line (sprintf "Token.t (* %s pattern *)" pattern_string)]
  | Token { name = _; description = Token } ->
      [Line "Token.t (* complex token *)"]
  | Token { name = _; description = External } ->
      [Line "Token.t (* external *)"]

  | Blank None -> [Line "unit (* blank *)"]
  | Blank (Some ident) -> [Line (sprintf "unit (* %s *)" ident)]
  | Repeat body ->
      [
        Inline (format_body body);
        Block [Line "list (* zero or more *)"]
      ]
  | Repeat1 body ->
      [
        Inline (format_body body);
        Block [Line "list (* one or more *)"]
      ]
  | Choice body_list ->
      [
        Line "[";
        Inline (format_choice body_list);
        Line "]"
      ]
  | Optional body ->
      [
        Inline (format_body body);
        Block [Line "option"]
      ]
  | Seq body_list ->
      format_seq body_list

and format_choice l =
  List.mapi (fun i body ->
    let name = sprintf "Case%i" i in
    Block [
      Line (sprintf "| `%s of" name);
      Block [Block (format_body body)];
    ]
  ) l

and format_seq l =
  let prod =
    List.map (fun body -> Block (format_body body)) l
    |> interleave (Line "*")
  in
  match l with
  | [_] -> prod
  | _ -> [Paren ("(", prod, ")")]

let format_rule (rule : rule) : Indent.t =
  let name = rule.name in
  let body = rule.body in
  if is_leaf body then
    if AST_grammar.is_inline name then
      [
        Line (sprintf "%s = unit" (trans name));
      ]
    else
      [
        Line (sprintf "%s = Token.t" (trans name));
      ]
  else
    [
      Line (sprintf "%s =" (trans name));
      Block (format_body rule.body);
    ]

let ppx = [
  Line "[@@deriving sexp_of]";
  Line "";
]

let format_types grammar =
  List.map (fun rule_group ->
    (List.map format_rule rule_group
     |> Codegen_util.format_typedefs
    ) @ ppx
  ) grammar.rules
  |> List.flatten

let generate_dumper grammar =
  [
    Line "";
    Line (sprintf "let dump root =");
    Block [
      Line (sprintf "sexp_of_%s root" grammar.entrypoint);
      Line (sprintf "|> Print_sexp.to_stdout;");
    ]
  ]

let format grammar =
  [
    Inline (preamble grammar);
    Inline (format_types grammar);
    Inline (generate_dumper grammar);
  ]

let generate grammar =
  let tree = format grammar in
  Indent.to_string tree

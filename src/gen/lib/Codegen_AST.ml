(*
   Code generator for the AST.ml file.
*)

open Printf
open AST_grammar
open Codegen_util

module E = Easy_format

let trans = translate_ident

(* Format ocaml type definitions. Might be reusable. *)
module Fmt = struct
  module Style = struct
    open Easy_format

    (* vertical sequence of items,
       intended to be used without parentheses or separators. *)
    let vert_seq = {
      list with
      wrap_body = `Force_breaks;
      indent_body = 0;
      align_closing = false;
      space_after_opening = false;
      space_before_closing = false
    }

    (* style suitable to use with parens and commas *)
    let paren_list = {
      list with
      align_closing = false;
      space_after_opening = false;
      space_before_closing = false
    }

    let horiz_sequence = {
      list with
      wrap_body = `No_breaks;
      stick_to_label = false;
      space_after_opening = false;
      space_before_closing = false
    }

    (* style suitable for polymorphic variants *)
    let left_sep_list = {
      list with
      separators_stick_left = false;
      space_before_separator = true;
      space_after_separator = true
    }

    (* style suitable for classic variants and products *)
    let left_sep_paren_list = {
      left_sep_list with
      space_after_opening = false;
      space_before_closing = false
    }
  end

  let atom s = E.Atom (s, E.atom)

  (* something followed by something else that gets indented if it doesn't
     fit on the same line. *)
  let label lhs rhs = E.Label ((lhs, E.label), rhs)

  let def lhs rhs =
    label (atom lhs) rhs

  let type_app param type_name =
    label param (atom type_name)

  let product l =
    match l with
    | [x] -> x
    | l -> E.List (("(", "*", ")", Style.left_sep_paren_list), l)

  let classic_variant l =
    let cases =
      List.map (fun (name, opt_arg) ->
        match opt_arg with
        | None -> atom name
        | Some arg -> label (atom (name ^ " of")) arg
      ) l
    in
    E.List (("", "|", "", Style.left_sep_paren_list), cases)

  let poly_variant l =
    let cases =
      List.map (fun (name, opt_arg) ->
        match opt_arg with
        | None -> atom ("`" ^ name)
        | Some arg -> label (atom ("`" ^ name ^ " of")) arg
      ) l
    in
    E.List (("[", "|", "]", Style.left_sep_list), cases)

  let record l =
    let fields =
      List.map (fun (name, type_) ->
        E.Label (
          (atom name, E.label),
          type_
        )
      ) l
    in
    E.List (("{", ";", "}", E.list), fields)

  let top_sequence l =
    E.List (("", "", "", Style.vert_seq), l)

  let typedef pos (name, rhs) =
    let is_first = (pos = 0) in
    let type_ =
      if is_first then
        "type"
      else
        "and"
    in
    def (sprintf "%s %s =" type_ name) rhs

  (* Insert the correct 'type' or 'and' from a list of OCaml
     type definitions.
  *)
  let recursive_typedefs defs =
    List.mapi typedef defs
    |> top_sequence

end

let preamble grammar =
  sprintf "\
(* Generated by ocaml-tree-sitter. *)
(*
   %s grammar

   entrypoint: %s
*)

open! Sexplib.Conv
open Ocaml_tree_sitter_run

"
    grammar.name
    grammar.entrypoint

let format_inlined_token (tok : token) =
  let name = tok.name in
  let type_ =
    match tok.description with
    | Constant cst -> sprintf "Token.t (* %S *)" cst
    | Pattern _pat -> sprintf "%s (*tok*)" (trans name)
    | Token -> sprintf "%s (*tok*)" (trans name)
    | External -> sprintf "%s (*tok*)" (trans name)
  in
  Fmt.atom type_

let format_body resolve body =
  let rec format_body
      ?(is_root = false)
      ?(is_variant_arg = false)
      body : E.t =
    match body with
    | Symbol ident ->
        format_type_ident ~is_variant_arg resolve ident
    | Token { name = _; description = Constant cst } ->
        Fmt.atom (sprintf "Token.t (* %S *)" cst)
    | Token { name = _; description = Pattern pat } ->
        let pattern_string =
          sprintf "%S" pat
          |> Codegen_util.safe_comment
        in
        Fmt.atom (sprintf "Token.t (* %s pattern *)" pattern_string)
    | Token { name = _; description = Token } ->
        Fmt.atom "Token.t (* complex token *)"
    | Token { name = _; description = External } ->
        Fmt.atom "Token.t (* external *)"
    | Blank ->
        Fmt.atom "unit (* blank *)"
    | Repeat body ->
        Fmt.type_app (format_body body) "list (* zero or more *)"
    | Repeat1 body ->
        Fmt.type_app (format_body body) "list (* one or more *)"
    | Choice case_list ->
        Fmt.poly_variant (format_choice ~is_root case_list)
    | Optional body ->
        Fmt.type_app (format_body body) "option"
    | Seq body_list ->
        Fmt.product (format_seq body_list)

  and format_choice ~is_root l =
    List.map (fun (name, body) ->
      (name, Some (format_body ~is_variant_arg:is_root body))
    ) l

  and format_seq l =
    List.map format_body l

  (*
     Inline symbols that refer to tokens or tuples.

     Tuples are inlined only under the following conditions:
     - must be the argument of a variant
     - variant must be at the root of the rule, i.e. not anonymous
     - may not be referenced more than once
   *)
  and format_type_ident ~is_variant_arg resolve ident =
    match resolve ident with
    | None -> assert false
    | Some (Symbol ident) ->
        format_type_ident ~is_variant_arg resolve ident
    | Some (Token tok) ->
        format_inlined_token tok
    | Some ((Seq _) as seq) when is_variant_arg ->
        format_body seq
    | Some _ ->
        Fmt.atom (trans ident)
  in
  format_body ~is_root:true body

let format_rule resolve (rule : rule) =
  (trans rule.name, format_body resolve rule.body)

let ppx =
  Fmt.top_sequence [
    Fmt.atom "[@@deriving sexp_of]";
    Fmt.atom ""
  ]

let resolver grammar =
  let tbl = Hashtbl.create 100 in
  List.iter (fun rule_group ->
    List.iter (fun (rule : rule) ->
      let name = rule.name in
      assert (not (Hashtbl.mem tbl name));
      Hashtbl.add tbl name rule.body
    ) rule_group
  ) grammar.rules;
  fun name ->
    printf "resolve %s\n%!" name;
    Hashtbl.find_opt tbl name

let format_types grammar =
  let resolve = resolver grammar in
  List.map (fun rule_group ->
    let defs = List.map (format_rule resolve) rule_group in
    Fmt.top_sequence [
      Fmt.recursive_typedefs defs;
      ppx
    ]
  ) grammar.rules
  |> Fmt.top_sequence

let generate_dumper grammar =
  sprintf "\

let dump root =
  sexp_of_%s root
  |> Print_sexp.to_stdout
"
    grammar.entrypoint

let generate grammar =
  let buf = Buffer.create 10_000 in
  Buffer.add_string buf (preamble grammar);
  E.Pretty.to_buffer buf (format_types grammar);
  Buffer.add_string buf (generate_dumper grammar);
  Buffer.contents buf

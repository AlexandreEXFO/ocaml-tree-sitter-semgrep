(*
   Code generator for the AST.ml file.

   This produces code similar to what's found in ../../run/lib/Sample.ml
*)

open Printf
open AST_grammar
open Indent.Types

let preamble = [ Line "\
(* Generated by ocaml-tree-sitter. *)

(* Disable warnings against unused variables *)
[@@@warning \"-26-27\"]

open Tree_sitter_output_t
let get_loc x = Loc.({ start = x.startPosition; end_ = x.endPosition})

let parse input_file =
  let input = Input_file.load input_file in
  let get_token x =
    Input_file.get_token input x.startPosition x.endPosition in

    let _parse_rule type_ parse_children =
      Combine.parse_node (fun x ->
        if x.type_ = type_ then
          parse_children x.children
        else
          None
      )
    in

    (* childless rule, from which we extract location and token. *)
    let _parse_leaf_rule type_ =
      Combine.parse_node (fun x ->
        if x.type_ = type_ then
          Some (get_loc x, get_token x)
        else
          None
      )
    in
"
]

let gen_parser_name name = "parse_" ^ name

let paren x =
  [
    Line "(";
    Block x;
    Line ")";
  ]

(*
   For some functions it's shorter to produce the function's body,
   for others it's shorter to produce the whole function expression.
   Each can be wrapped to convert to the other form.
*)
type code =
  | Fun of Indent.t (* takes one argument of type 'node list' *)
  | Body of Indent.t (* assumes one argument, 'nodes' *)

let as_fun = function
  | Fun code -> code
  | Body code ->
      [
        Line "(fun nodes ->";
        Block code;
        Line ")";
      ]

let as_body = function
  | Fun code ->
      [
        Line "(";
        Block code;
        Line ") nodes";
      ]
  | Body code -> code

let gen_lazy_or num_cases =
  assert (num_cases > 0);
  let rec gen i =
    if i = num_cases - 1 then
      [ Line (sprintf "parse_case%i nodes" i) ]
    else
      [
        Line (sprintf "match parse_case%i nodes with" i);
        Line "| Some _ as res -> res";
        Line "| None ->";
        Block [Block (gen (i + 1))];
      ]
  in
  gen 0

let as_sequence body =
  match body with
  | Seq bodies -> bodies
  | body -> [body]

(* produce "(e0, (e1, e2))" for n = 3 *)
let gen_nested_pairs n =
  let buf = Buffer.create 50 in
  let rec gen buf pos =
    if pos < n - 1 then
      bprintf buf "(e%i, %a)" pos gen (pos + 1)
    else if pos = n - 1 then
      bprintf buf "e%i" pos
    else
      assert false
  in
  assert (n >= 1);
  gen buf 0;
  Buffer.contents buf

let gen_match_end parser_code =
  [
    Line "Combine.parse_last (";
    Block (parser_code |> as_fun);
    Line ")";
  ]

let gen_result_tuple n =
  sprintf "(%s)"
    (Codegen_util.enum n
     |> List.map (fun pos -> sprintf "e%i" pos)
     |> String.concat ", ")

let rec gen_parser_code body =
  match body with
  | Symbol s ->
      Fun [
        Line (sprintf "parse_%s" s)
      ]
  | String s ->
      Fun [
        Line (sprintf "_parse_leaf_rule %S" s)
      ]
  | Pattern s ->
      Fun [
        Line (sprintf "_parse_leaf_rule %S" s) (* does this happen? *)
      ]
  | Blank ->
      Fun [
        Line (sprintf "_parse_token %S" "blank" (* ? *))
      ]
  | Repeat body ->
      Fun [
        Line "Combine.parse_repeat (";
        Block (gen_parser_fun body);
        Line ")";
      ]
  | Repeat1 body ->
      Fun [
        Line "Combine.parse_repeat (";
        Block (gen_parser_fun body);
        Line ")";
      ]
  | Choice bodies ->
      gen_choice bodies
  | Seq bodies ->
      let wrapped_result = gen_result_tuple (List.length bodies) in
      gen_seq ~wrapped_result bodies

and gen_parser_fun body =
  gen_parser_code body |> as_fun

and gen_parser_body body =
  gen_parser_code body |> as_body

and gen_seq ~wrapped_result bodies =
  let rec gen bodies =
    match bodies with
    | [] -> assert false
    | [last] ->
        gen_parser_fun last
    | body :: bodies ->
        [
          Line "let parse_elt =";
          Block (gen_parser_fun body);
          Line "in";
          Line "let parse_tail =";
          Block (gen bodies);
          Line "in";
          Line "Combine.parse_seq parse_elt parse_tail";
        ]
  in
  let len = List.length bodies in
  Body [
    Line "let parse_nested =";
    Block (gen bodies);
    Line "in";
    Line "match parse_nested nodes with";
    Line (
      sprintf "| Some (%s, nodes) -> Some (%s, nodes)"
        (gen_nested_pairs len)
        wrapped_result
    );
    Line "| None -> None";
  ]

and gen_choice cases =
  let num_cases = List.length cases in
  Body [
    Inline (List.mapi (fun i case -> Inline (gen_parse_case i case)) cases);
    Inline (gen_lazy_or num_cases);
  ]

(*
   A case is a sequence, which in addition:
   - must match the end of input
   - wraps its result in a constructor like `Case0 rather than a plain tuple.
*)
and gen_parse_case i body =
  let bodies = as_sequence body in
  let len = List.length bodies in
  let wrapped_result =
    sprintf "`Case%i %s"
      i
      (gen_result_tuple len)
  in
  [
    Line (sprintf "let parse_case%i nodes =" i);
    Block (gen_seq ~wrapped_result bodies |> gen_match_end);
    Line "in";
  ]

let is_leaf = function
  | Symbol _
  | String _
  | Pattern _
  | Blank -> true
  | Repeat _
  | Repeat1 _
  | Choice _
  | Seq _ -> false

let gen_rule_parser pos rule =
  let is_first = (pos = 0) in
  let let_ =
    (* TODO: minimize recursive calls with topological sort of strongly
       connected components. See https://github.com/dmbaturin/ocaml-tsort *)
    match is_first with
    | true -> "let rec"
    | false -> "and"
  in
  let ident, rule_body = rule in
  if is_leaf rule_body then
    [
      Line (sprintf "%s %s = _parse_leaf_rule %S"
              let_ (gen_parser_name ident) ident);
    ]
  else
    [
      Line (sprintf "%s %s = _parse_rule %S ("
              let_ (gen_parser_name ident) ident);
      Block (gen_parser_fun rule_body);
      Line ")";
    ]

let gen grammar =
  let entrypoint = grammar.entrypoint in
  let rule_parsers =
    List.mapi (fun i rule -> Inline (gen_rule_parser i rule)) grammar.rules in
  [
    Inline preamble;
    Block [
      Inline rule_parsers;
      Line "in";
      Line (sprintf "Combine.parse_root %s" (gen_parser_name entrypoint));
    ]
  ]

let generate grammar =
  let tree = gen grammar in
  Indent.to_string tree

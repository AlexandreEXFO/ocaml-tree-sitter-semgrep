(*
   Code generator for the AST.ml file.

   This produces code similar to what's found in ../../run/lib/Sample.ml
*)

open Printf
open AST_grammar
open Indent.Types

let preamble = [ Line "\
(* Generated by ocaml-tree-sitter. *)

(* Disable warnings against unused variables *)
[@@@warning \"-26-27\"]

open Tree_sitter_output_t
let get_loc x = Loc.({ start = x.startPosition; end_ = x.endPosition})

let parse input_file =
  let input = Input_file.load input_file in
  let get_token x =
    Input_file.get_token input x.startPosition x.endPosition in

  let _parse_token type_ =
    Combine.parse_node (fun x ->
      if x.type_ = type_ then
        Some (get_loc x, get_token x)
      else
        None
    )
  in
"
]

let gen_parser_name name = "parser_" ^ name

let paren x =
  [
    Line "(";
    Block x;
    Line ")";
  ]

(* Call a parsing function on the standard argument name. *)
let apply parser_fun =
  [
    Line "(";
    Block parser_fun;
    Line ") nodes";
  ]

let gen_lazy_or num_cases =
  assert (num_cases > 0);
  let rec gen i =
    if i = num_cases - 1 then
      [ Line (sprintf "parse_case%i" i) ]
    else
      [
        Line (sprintf "match parse_case%i nodes with" i);
        Line "| Some _ as res -> res";
        Line "None ->";
        Block (gen (i + 1));
      ]
  in
  gen 0

let as_sequence body =
  match body with
  | Seq bodies -> bodies
  | body -> [body]

(* produce "(e0, (e1, e2))" for n = 3 *)
let gen_nested_pairs n =
  let buf = Buffer.create 50 in
  let rec gen buf pos =
    if pos < n - 1 then
      bprintf buf "(e%i, %a)" pos gen (pos + 1)
    else if pos = n - 1 then
      bprintf buf "e%i" pos
    else
      assert false
  in
  assert (n >= 1);
  gen buf 0;
  Buffer.contents buf

let gen_match_end parser_fun =
  [
    Line "Combine.parse_last (";
    Block parser_fun;
    Line ")";
  ]

let gen_result_tuple n =
  sprintf "(%s)"
    (Codegen_util.enum n
     |> List.map (fun pos -> sprintf "e%i" pos)
     |> String.concat ", ")

let rec gen_parser_fun body =
  match body with
  | Symbol s
  | String s ->
      [
        Line (sprintf "_parse_token %S" s)
      ]
  | Pattern s ->
      [
        Line (sprintf "_parse_token %S" s) (* doesn't seem right *)
      ]
  | Blank ->
      [
        Line (sprintf "_parse_token %S" "blank" (* ? *))
      ]
  | Repeat body ->
      [
        Line "Combine.parse_repeat (";
        Block (gen_parser_fun body);
        Line ")";
      ]
  | Repeat1 body ->
      [
        Line "Combine.parse_repeat (";
        Block (gen_parser_fun body);
        Line ")";
      ]
  | Choice bodies ->
      gen_choice bodies
  | Seq bodies ->
      let wrapped_result = gen_result_tuple (List.length bodies) in
      gen_seq ~wrapped_result bodies

and gen_seq ~wrapped_result bodies =
  let rec gen bodies =
    match bodies with
    | [] -> assert false
    | [last] ->
        gen_parser_fun last
    | body :: bodies ->
        [
          Line "let parse_elt =";
          Block (gen_parser_fun body);
          Line "in";
          Line "let parse_tail =";
          Block (gen bodies);
          Line "in";
          Line "Combine.parse_seq parse_elt parse_tail";
        ]
  in
  let len = List.length bodies in
  [
    Inline (gen bodies);
    Line "match parse_nested nodes with";
    Line (
      sprintf "| Some (%s, nodes) -> Some (%s, nodes)"
        (gen_nested_pairs len)
        wrapped_result
    );
    Line "| None -> None";
  ]

and gen_choice cases =
  let num_cases = List.length cases in
  [
    Inline (List.mapi (fun i case -> Inline (gen_parse_case i case)) cases);
    Inline (gen_lazy_or num_cases);
  ]

(*
   A case is a sequence, which in addition:
   - must match the end of input
   - wraps its result in a constructor like `Case0 rather than a plain tuple.
*)
and gen_parse_case i body =
  let bodies = as_sequence body in
  let len = List.length bodies in
  let wrapped_result =
    sprintf "`Case%i %s"
      i
      (gen_result_tuple len)
  in
  [
    Line (sprintf "let parse_case%i nodes =" i);
    Block (gen_seq ~wrapped_result bodies |> gen_match_end);
    Line "in";
  ]

let gen_rule_parser pos rule =
  let is_first = (pos = 0) in
  let let_ =
    (* TODO: minimize recursive calls with topological sort of strongly
       connected components. See https://github.com/dmbaturin/ocaml-tsort *)
    match is_first with
    | true -> "let rec"
    | false -> "and"
  in
  let ident, rule_body = rule in
  [
    Line (sprintf "%s %s nodes =" let_ (gen_parser_name ident));
    Block (gen_parser_fun rule_body |> apply);
  ]

let gen grammar =
  let entrypoint = grammar.name in
  let rule_parsers =
    List.mapi (fun i rule -> Inline (gen_rule_parser i rule)) grammar.rules in
  [
    Inline preamble;
    Block [
      Inline rule_parsers;
      Line "in";
      Line (gen_parser_name entrypoint);
    ]
  ]

let generate grammar =
  let tree = gen grammar in
  Indent.to_string tree

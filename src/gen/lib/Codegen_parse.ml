(*
   Code generator for the CST.ml file.

   This produces code similar to what's found in ../../run/lib/Sample.ml
*)

open Printf
open CST_grammar
open Indent.Types

(* Set on the ocaml-tree-sitter command line. *)
let debug_trace = ref false

(* All rule names and other names directly defined in grammar.json
   must go through this translation. For example, it turns
   "true" into "true_" because "true" is a reserved keyword in the generated
   code.
*)
let trans = Codegen_util.translate_ident

let mli_contents grammar : string =
  let lang = grammar.name in
  let root_type = grammar.entrypoint in
  sprintf {|
(**
    Functions for parsing %s programs into a CST.

    Generated by ocaml-tree-sitter.
*)

(** Parse a %s program from a string into a typed OCaml CST. *)
val string : ?src_file:string -> string -> CST.%s option

(** Parse a %s program from a file into a typed OCaml CST. *)
val file : string -> CST.%s option

(** Whether to print debugging information. Default: %B. *)
val debug : bool ref

(** The original tree-sitter parser. *)
val ts_parser : Tree_sitter_bindings.Tree_sitter_API.ts_parser

(** Parse a program into a tree-sitter CST. *)
val parse_source_string :
   ?src_file:string -> string -> Tree_sitter_run.Tree_sitter_parsing.t

(** Parse a source file into a tree-sitter CST. *)
val parse_source_file : string -> Tree_sitter_run.Tree_sitter_parsing.t

(** Parse a tree-sitter CST into an OCaml typed CST. *)
val parse_input_tree :
  Tree_sitter_run.Tree_sitter_parsing.t ->
  CST.%s option
|}
    lang
    lang (trans root_type)
    lang (trans root_type)
    !debug_trace
    (trans root_type)

(* Emit code that wraps around a parsing function
   if runtime tracing is enabled.
*)
let trace_gen trace_fun name (reader : Indent.t) =
  if !debug_trace then
    [
      Group [
        Line (sprintf "fun nodes -> Combine.%s %S (" trace_fun name);
        Block reader;
        Line ") nodes"
      ]
    ]
  else
    reader

(* works with any function of type _ -> _ option *)
let trace name reader =
  trace_gen "trace" name reader

let debug_log s =
  if !debug_trace then
    Line (sprintf "print_endline %S;" s)
  else
    Inline []

let constant_header = "\
(* Generated by ocaml-tree-sitter. *)

(* Disable warnings against unused variables *)
[@@@warning \"-26-27\"]

open Tree_sitter_bindings
open Tree_sitter_run
open Tree_sitter_output_t
let get_loc x = Loc.({ start = x.start_pos; end_ = x.end_pos })
"

let declare_externals lang = sprintf "\
external create_parser :
  unit -> Tree_sitter_API.ts_parser = \"octs_create_parser_%s\"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file
"
    lang

let gen_extras grammar =
  let items = List.map (fun name ->
    Line (sprintf "%S;" name)
  ) grammar.extras
  in
  [
    Line "let extras = [";
    Block items;
    Line "]";
    Line ""
  ]

let preamble ~cst_module_name grammar =
  [
    Line constant_header;
    Line (declare_externals grammar.name);
    Line (sprintf "let debug = ref %B" !debug_trace);
    Line "";
    Inline (gen_extras grammar);
    Line (sprintf "\
let parse_input_tree input_tree : %s.%s option =
  let root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let get_token x = Src_file.get_token src x.start_pos x.end_pos in

  if !debug then (
    Printf.printf \"input from tree-sitter:\\n\";
    Tree_sitter_dump.to_stdout [root_node];
    flush stdout;
    Printf.printf \"ocaml-tree-sitter trace:\\n\"
  );

  let get_token x =
    Src_file.get_token src x.start_pos x.end_pos in

  (* Parse a single node that has no children.
     We extract its location and source code (token). *)
  let _parse_leaf_rule type_ =
    Combine.parse_node (fun x ->
      if x.type_ = type_ then
        Some (get_loc x, get_token x)
      else
        None
    )
  in
"
            cst_module_name (trans grammar.entrypoint)
         )
  ]

let create_cache prefix id type_ =
  Inline [
    Line (sprintf "let %s%s : %s Combine.Memoize.t ="
            prefix (trans id) type_);
    Block [Line "Combine.Memoize.create () in"];
  ]

let gen_rule_cache ~cst_module_name (rule : rule) =
  let primary_name = rule.name in
  let leaf = is_leaf rule.body in
  let cache_type =
    if leaf then
      "Token.t"
    else
      sprintf "%s.%s" cst_module_name (trans primary_name)
  in
  [create_cache "cache_" primary_name cache_type]

(*
   Generate a list of bindings, without 'let', 'and' etc.
   for reading some input of type TYPE from a sequence of nodes.

   We create 3 kinds of functions:

   * parse_inline_TYPE:
     - called by parse_children_TYPE, which ensures it consumes the whole input
     - called by inline rules, whose name starts with '_'
   * parse_children_TYPE:
     - calls parse_inline_TYPE
   * parse_node_TYPE:
     - cached
     - reads one node, checks its 'type' field and calls parse_children_TYPE
       on its 'children' field.

   If the rule matches a leaf node, i.e. a node with no children, we never
   need to generate parse_children_TYPE.

   In addition to its primary name, a rule may have aliases.
   - For each alias, we must generate its own parse_node_ALIAS function,
     which calls parse_children_TYPE.
   - parse_inline_TYPE is called directly for aliases whose name starts
     with '_'. There's no need for a dedicated parse_inline_ALIAS.
*)
let gen_rule_parser_bindings ~cst_module_name (rule : rule) =
  let name = rule.name in
  let body = rule.body in
  if is_leaf body then (
    (* Generate parse_inline for the primary rule name.
       Generate parse_node for each name that needs it. *)
    let parse_inline_binding =
      let fun_name = "parse_inline_" ^ trans name in
      [
        Line (sprintf "%s : unit Combine.reader =" fun_name);
        Block (trace fun_name [
          Line "(fun nodes ->";
          Block [
            Line "Combine.parse_success nodes";
          ];
          Line ")";
        ])
      ]
    in
    let parse_node_binding =
      let fun_name = "parse_node_" ^ trans name in
      [
        Line (sprintf "%s : Token.t Combine.reader ="
                fun_name);
        Block (trace fun_name [
          Line "(fun nodes ->";
          Block [
            Line (sprintf "Combine.Memoize.apply cache_%s" (trans name));
            Block [
              Line (sprintf "(_parse_leaf_rule %S) nodes" name);
            ]
          ];
          Line ")";
        ])
      ]
    in
    [parse_inline_binding; parse_node_binding]
  )
  else
    (* Generate parse_inline and parse_children for the primary rule name.
       Generate parse_node for each name that needs it. *)
    let parse_inline_binding =
      let fun_name = sprintf "parse_inline_%s" (trans name) in
      [
        Line (sprintf "%s check_tail : %s.%s Combine.reader ="
                fun_name
                cst_module_name (trans name));
        Block (
          trace fun_name
            (Codegen_matcher.generate_ocaml body);
        )
      ]
    in
    let parse_children_binding =
      let fun_name = sprintf "parse_children_%s" (trans name) in
      [
        Line (sprintf "%s : %s.%s Combine.full_seq_reader ="
                fun_name
                cst_module_name (trans name));
        Block (trace fun_name [
          Line "(fun nodes ->";
          Block [
            Line (sprintf "Combine.parse_full_seq parse_inline_%s nodes"
                    (trans name));
          ];
          Line ")"
        ])
      ]
    in
    let parse_node_binding =
      let fun_name = sprintf "parse_node_%s" (trans name) in
      [
        Line (sprintf "%s : %s.%s Combine.reader ="
                fun_name
                cst_module_name (trans name));
        Block (trace fun_name [
          Line "(fun nodes ->";
          Block [
            Line (sprintf "Combine.Memoize.apply cache_%s ("
                    (trans name));
            Block [
              Line (sprintf "Combine.parse_rule %S parse_children_%s"
                      name (trans name));
            ];
            Line ") nodes";
          ];
          Line ")"
        ])
      ]
    in
    [parse_inline_binding; parse_children_binding; parse_node_binding]

let gen ~cst_module_name grammar =
  let entrypoint = grammar.entrypoint in
  let rule_defs =
    List.map (fun rule_group ->
      let is_rec =
        match rule_group with
        | [x] -> x.is_rec
        | _ -> true
      in
      let rule_caches =
        List.map (fun rule ->
          Inline (gen_rule_cache ~cst_module_name rule)
        ) rule_group in
      let rule_parsers =
        let bindings =
          List.map (fun rule ->
            gen_rule_parser_bindings ~cst_module_name rule
          ) rule_group
          |> List.flatten
        in
        Codegen_util.format_bindings ~is_rec ~is_local:true bindings
      in
      [
        Inline rule_caches;
        Inline rule_parsers;
      ]
    ) grammar.rules
    |> List.flatten
  in
  [
    Inline (preamble ~cst_module_name grammar);
    Block [
      Inline rule_defs;
      Line "let result =";
      Block [
        Line (sprintf "Combine.parse_root ~extras parse_node_%s root_node;"
                (trans entrypoint));
      ];
      Line "in";
      Line "if !debug then (";
      Block [
        Line "Printf.printf \"---\n\";";
        Line "flush stdout";
      ];
      Line ");";
      Line "result"
    ];
  ]

let ml_trailer = {|
let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree
|}

let generate ~cst_module_name grammar =
  let tree = gen ~cst_module_name grammar in
  let ml_contents = Indent.to_string tree ^ ml_trailer in
  mli_contents grammar, ml_contents
